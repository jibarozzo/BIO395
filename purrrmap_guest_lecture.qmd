---
title: Vector Manipulation and Iteration in R
subtitle: Understanding Vectors, Lists, and Purrr Package Functions
author: Bolívar Aponte Rolón
date: "2024-11-08"
format:
  revealjs:
    #   - ../../meds-slides-styles.scss
    slide-number: true
    # code-link: true
    highlight-style: a11y
    chalkboard: true
    # theme: 
editor_options: 
  chunk_output_type: console
execute:
    echo: true
    eval: true
---

```{r}
#| label: setup
library(tidyverse)
library(gapminder)

```

# Introduction

## Overview

-   R's data structures, vectorized operations, and

-   functional programming with purrr

-   Importance of writing clear, reusable code 

# {{< fa brands r-project title="R logo" >}} Vector Basics
<!-- <div class="page-center vertical-center"> -->
<!-- <p class="custom-subtitle bottombr">{{< fa brands r-project title="R logo" >}} Vector Basics?</p> -->
<!-- </div> -->

## Atomic Vectors

Simple data structures in R that hold elements of the same type. 

Types: `logical`, `integer`, `double`, and `character`


```{r}
numeric_vector <- c(1, 2, 3)
character_vector <- c("a", "b", "c")

numeric_vector

character_vector
```

Other, more complex vectors: *matrices*, *lists*, and *tibbles*.


## Vector Coercion

R automatically converts data types in vectors. 

Hierarchy: Logical → Integer → Double → Character.

```{r}
mixed_vector <- c(TRUE, 2, "text")
print(mixed_vector) # Coerces to character
```

## Vector Coercion (cont.)

Explicit coercion: as.double(), as.integer(), as.character(), as.logical(), etc.

```{r}
as.character(c(1, 1.2, 1.23, 1.234))
```

Note the quotation marks in the output confirm our coercion worked as expected.

## Checking for vector types

Usefule functions:

- `typeof()` determines the type of a vector
- The `is.*()` functions (e.g. `is.character()`) test if a vector is of a specific type
- The `as.*()` functions (e.g. `as.character()`) deliberately coerce a vector to a specific type

## Vector Indexing and Subsetting

Ways of accessing:

- Single or multiple elements using `\[\]`. 
- Access using names (named vectors).

```{r}
# Named vector
vec <- c(alpha = 1, beta = 2, gamma = 3)
vec["beta"]  # Accessing by name
vec[c(1, 2)] # Accessing multiple elements

# Unnamed vector
unvec <- c("alpha", "beta", "gamma")
unvec[2]
unvec
```

::: {.callout-note}
{{< fa brands r-project title="R logo" >}} is a one-indexed language, while {{< fa brands python >}} is a zero-indexed language.
:::

## Logical Indexing

Subset vectors based on conditions.

```{r}

num_vec <- c(10, 15, 20, 25)
num_vec[num_vec > 15]
```

## Modifying in place
```{r}
vec <- c(1, 4, 9, 16, 25)
vec

vec[1] <- 0
vec
```

::: {.callout-warning}
This is a permanent change. You are in fact overwriting the value.
:::

# List Data Structures in R

## Introduction to Lists

Lists are recursive vectors that can hold elements of *different* types. 
Examples: Lists within lists and different data types.

```{r}
my_list <- list(num = 1, char = "text", vec = c(1, 2, 3))
my_list
```

## Accessing List Elements

- Single vs. Double Brackets: `\[ \]` vs. `\[\[ \]\]`. 
- Using `\$` for named elements.

```{r}
my_list[["num"]]
my_list$vec
```

# Coding best practices and functional programming

## It's easy to write bad code
Characteristics of bad unsustainable code

- Comments (too many or too obvious)
- Inconsistent naming and ambiguous names
- Duplicate code
- Data clumps
- Intermmediary objects and Duplicate identifiers
- Absolute paths
- Too much indentation


[Best Practices for Scientific Computing](https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1001745)

[External list of resources](https://bookdown.org/alapo/learnr/intro.html#list-of-resources)

## Commenting for Clarity

Explain purpose, not syntax the *obvious*.

The *obvious* is something the code should do by itself.

Comments that clarify decisions.
```{r}
#| eval: false
#| echo: true
# Extracts the mean of each column in the data frame
map(data, mean)

# Selecting subset values for initial tests
sub_tests <- data |>
  select(column_a:column_b)
```

## N0 NaMing KonV3nz1on {.smaller}

:::: {.columns}

::: {.column width="65%"}
 Choose a style and be consistent

**`snake_case`** is preferred for object names
```{r}
#| eval: false
#| echo: true

# Strive for:
short_flights <- flights |> filter(air_time < 60)

# Avoid:
SHORTFLIGHTS <- flights |> filter(air_time < 60)
```

You can have conventions for different elements:

- **Files**: underscore_separated, all lower case: e.g. *numeric_version*
- **Functions**: period.separated, all lower case: e.g. *my.function*
- **Variables**: lowerCamelCase: e.g. *addTaskCall*

See the [*tidyverse* style guide](https://style.tidyverse.org/)
:::

::: {.column width="35%"}
![](assets/programmerhumor-io-backend-memes.webp)
:::
::::

## Avoiding Code Duplication

We can refactor repetitive code by creating functions
```{r}
#| label: copy_plots
#| echo: true
#| eval: false
#| warning: false
#| message: false

# Afghanistan
gapminder |>
  filter(country == "Afghanistan" ) |>
ggplot(aes(x = year, y = lifeExp)) +
  geom_jitter(position = position_jitter(width = 0.1, height = 0), alpha = 1) +
  geom_smooth(method = lm, se = T, level = 0.95, na.rm = F) +
  labs(title = "Afghanistan")

# United States
gapminder |>
  filter(country == "United States" ) |>
  ggplot(aes(x = year, y = lifeExp)) +
  geom_jitter(position = position_jitter(width = 0.1, height = 0), alpha = 1) +
  geom_smooth(method = lm, se = T, level = 0.95, na.rm = F) +
  labs(title = "United States")

# United Kingdom
gapminder |>
  filter(country == "United Kingdom" ) |>
  ggplot(aes(x = year, y = lifeExp)) +
  geom_jitter(position = position_jitter(width = 0.1, height = 0), alpha = 1) +
  geom_smooth(method = lm, se = T, level = 0.95, na.rm = F) +
  labs(title = "United Kingdom")

```


## 
In to this *reusable* function:
```{r}
#| label: ggplot_function
#| echo: true
#| warning: false
#| message: false

lm_ggplot <- function(data, .country, x, y) {
data |>
    filter(country == {{.country}} ) |>
    ggplot(aes(x = {{x}}, y = {{y}})) +
    geom_jitter(position = position_jitter(width = 0.1, height = 0), alpha = 1) +
    geom_smooth(method = lm, se = T, level = 0.95, na.rm = F) +
    labs(title = .country)
}
```

## 
Let's test our function

:::: {.columns}

::: {.column width="45%"}
```{r}
#| label: test_afghanistan
#| message: false

lm_ggplot(gapminder, .country = "Afghanistan", x = year, y = lifeExp)
```
:::

::: {.column width="45%"}
```{r}
#| label: test_usa
#| message: false

lm_ggplot(gapminder, .country = "United States", x = year, y = lifeExp)
```
:::

::::




## Using Parameters and Defaults

Definition: Setting default values for arguments. Example:

```{r}
plot_data <- function(x, y = NULL) {
  if (!is.null(y)) plot(x, y)
  else plot(x)
}

```




# Practical Applications

## Trimming the excess ...


## Let's write a function

How would we write a function that creates a boxplot comparing the mean life expectancy between countries.





## Introduction to `purrr`

Iterating over data structures in a functional way.  Readable code, no need for explicit loops.

## Slide 10: map() Function

Definition: Applies a function to each element of a list or vector. Example:

```{r}
library(purrr)
map(1:3, ~ .x ^ 2)
```

## Slide 11: map() Variants

Types: map_dbl(), map_chr(), map_int(), map_lgl() Example: Using map_dbl() for numerical output.

```{r}
map_dbl(c(1.1, 2.5, 3.9), round)
```

## Slide 12: Mapping Over Data Frames

Explanation: Using map() to iterate over data frame columns. Example:

```{r}
data <- data.frame(a = 1:5, b = 6:10)
map(data, mean)
```

## Slide 13: Applying Functions with map() and Additional Arguments

Explanation: Pass extra arguments to mapped function. Example:

```{r}
map(c(10, 20, 30), runif, min = 0, max = 5)
```

## Slide 14: walk() for Side Effects

Definition: walk() performs side effects, often for I/O operations. Example:

```{r}
walk(1:3, ~ print(.x))
```



## Slide 19: Example - Applying map() for Data Transformation

Description: Using map() for transformations across columns. Example:

```{r}
df <- data.frame(x = c(1, 2), y = c(3, 4))
map(df, sqrt)
```

## Slide 20: Example - walk() for File Operations

Description: Using walk() to save multiple plots. Example:

```{r}
walk(names(iris)[1:4], ~ hist(iris[[.x]], main = .x))
```

## Slide 21: List Columns and Nested Data Frames

Purpose: Store data frames or lists within columns for complex data structures. Example:

```{r}
#| eval: false
df <- tibble(group = c("A", "B"), data = list(data1, data2))
```

# Section 6: Conclusion and Best Practices

## Slide 22: Recap - Key Points on Vectors and Lists

Summary: Types of vectors, coercion rules, and list usage.

## Slide 23: Recap - Functional Programming with purrr

Summary: Benefits of map() and walk() for iteration and side effects.

## Slide 24: Recap - Coding Best Practices

Summary: Clarity, readability, and reusability in coding.

## Slide 25: Resources and Further Reading

Books: R for Data Science, Advanced R Web Resources: purrr documentation, RStudio guides.

## Slide 26: Q&A

Closing Slide: Thank attendees and open for questions.
