---
title: Vector Manipulation and Iteration in R
subtitle: Understanding Vectors, Lists, and Purrr Package Functions
author: Bolívar Aponte Rolón
date: "2024-11-08"
format:
  revealjs:
    #   - ../../meds-slides-styles.scss
    slide-number: true
    # code-link: true
    highlight-style: a11y
    chalkboard: true
    # theme: 
editor_options: 
  chunk_output_type: console
execute:
    echo: true
    eval: true
---

```{r}
#| label: setup

library(tidyverse)
library(gapminder)

```

# Introductio

## Overview

-   R's data structures, vectorized operations, and

-   functional programming with purrr

-   Importance of writing clear, reusable code 

# {{< fa brands r-project title="R logo" >}} Vector Basics
<!-- <div class="page-center vertical-center"> -->
<!-- <p class="custom-subtitle bottombr">{{< fa brands r-project title="R logo" >}} Vector Basics?</p> -->
<!-- </div> -->

## Atomic Vectors

Simple data structures in R that hold elements of the same type. 

Types: `logical`, `integer`, `double`, and `character`


```{r}
numeric_vector <- c(1, 2, 3)
character_vector <- c("a", "b", "c")

numeric_vector

character_vector
```

Other, more complex vectors: *matrices*, *lists*, and *tibbles*.


## Vector Coercion

R automatically converts data types in vectors. 

Hierarchy: Logical → Integer → Double → Character.

```{r}
mixed_vector <- c(TRUE, 2, "text")
print(mixed_vector) # Coerces to character
```

## Vector Coercion (cont.)

Explicit coercion: as.double(), as.integer(), as.character(), as.logical(), etc.

```{r}
as.character(c(1, 1.2, 1.23, 1.234))
```

Note the quotation marks in the output confirm our coercion worked as expected.

## Checking for vector types

Usefule functions:

- `typeof()` determines the type of a vector
- The `is.*()` functions (e.g. `is.character()`) test if a vector is of a specific type
- The `as.*()` functions (e.g. `as.character()`) deliberately coerce a vector to a specific type

## Vector Indexing and Subsetting

Ways of accessing:

- Single or multiple elements using `\[\]`. 
- Access using names (named vectors).

```{r}
# Named vector
vec <- c(alpha = 1, beta = 2, gamma = 3)
vec["beta"]  # Accessing by name
vec[c(1, 2)] # Accessing multiple elements

# Unnamed vector
unvec <- c("alpha", "beta", "gamma")
unvec[2]
unvec
```

::: {.callout-note}
{{< fa brands r-project title="R logo" >}} is a one-indexed language, while {{< fa brands python >}} is a zero-indexed language.
:::

## Logical Indexing

Subset vectors based on conditions.

```{r}

num_vec <- c(10, 15, 20, 25)
num_vec[num_vec > 15]
```

## Modifying in place
```{r}
vec <- c(1, 4, 9, 16, 25)
vec

vec[1] <- 0
vec
```

::: {.callout-warning}
This is a permanent change. You are in fact overwriting the value.
:::

# List Data Structures in R

## Introduction to Lists

Lists are recursive vectors that can hold elements of *different* types. 
Examples: Lists within lists and different data types.

```{r}
my_list <- list(num = 1, char = "text", vec = c(1, 2, 3))
my_list
```

## Accessing List Elements

- Single vs. Double Brackets: `\[ \]` vs. `\[\[ \]\]`. 
- Using `\$` for named elements.

```{r}
my_list[["num"]]
my_list$vec
```

# Section 3: Functional Programming with purrr

## Slide 9: Introduction to purrr

Purpose: Iterating over data structures in a functional way. Benefits: Readable code, no need for explicit loops.

## Slide 10: map() Function

Definition: Applies a function to each element of a list or vector. Example:

```{r}
library(purrr)
map(1:3, ~ .x ^ 2)
```

## Slide 11: map() Variants

Types: map_dbl(), map_chr(), map_int(), map_lgl() Example: Using map_dbl() for numerical output.

```{r}
map_dbl(c(1.1, 2.5, 3.9), round)
```

## Slide 12: Mapping Over Data Frames

Explanation: Using map() to iterate over data frame columns. Example:

```{r}
data <- data.frame(a = 1:5, b = 6:10)
map(data, mean)
```

## Slide 13: Applying Functions with map() and Additional Arguments

Explanation: Pass extra arguments to mapped function. Example:

```{r}
map(c(10, 20, 30), runif, min = 0, max = 5)
```

## Slide 14: walk() for Side Effects

Definition: walk() performs side effects, often for I/O operations. Example:

```{r}
walk(1:3, ~ print(.x))
```

# Section 4: Coding Best Practices

## Slide 15: Writing Clear Functions

Purpose: Enhances reusability and readability. Example: Naming conventions and argument defaults.

```{r}
plot_histogram <- function(data, col) {
  hist(data[[col]], main = paste("Histogram of", col))
}
```

## Slide 16: Commenting for Clarity

Best Practice: Explain purpose, not syntax. Example: Comments that clarify decisions.

```{r}
# Extracts the mean of each column in the data frame
map(data, mean)
```

## Slide 17: Using Parameters and Defaults

Definition: Setting default values for arguments. Example:

```{r}
plot_data <- function(x, y = NULL) {
  if (!is.null(y)) plot(x, y)
  else plot(x)
}

```

## Slide 18: Avoiding Code Duplication

Purpose: Refactor repeated code into functions. Example: Creating helper functions.

# Section 5: Practical Applications

## Slide 19: Example - Applying map() for Data Transformation

Description: Using map() for transformations across columns. Example:

```{r}
df <- data.frame(x = c(1, 2), y = c(3, 4))
map(df, sqrt)
```

## Slide 20: Example - walk() for File Operations

Description: Using walk() to save multiple plots. Example:

```{r}
walk(names(iris)[1:4], ~ hist(iris[[.x]], main = .x))
```

## Slide 21: List Columns and Nested Data Frames

Purpose: Store data frames or lists within columns for complex data structures. Example:

```{r}
#| eval: false
df <- tibble(group = c("A", "B"), data = list(data1, data2))
```

# Section 6: Conclusion and Best Practices

## Slide 22: Recap - Key Points on Vectors and Lists

Summary: Types of vectors, coercion rules, and list usage.

## Slide 23: Recap - Functional Programming with purrr

Summary: Benefits of map() and walk() for iteration and side effects.

## Slide 24: Recap - Coding Best Practices

Summary: Clarity, readability, and reusability in coding.

## Slide 25: Resources and Further Reading

Books: R for Data Science, Advanced R Web Resources: purrr documentation, RStudio guides.

## Slide 26: Q&A

Closing Slide: Thank attendees and open for questions.
